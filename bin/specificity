#!/usr/bin/env node

var program = require('commander'),
    fs = require('fs'),
    path = require('path'),
    glob = require('glob'),
    specificity = require('..'),
    pkg = JSON.parse(fs.readFileSync(path.join(__dirname, '..', 'package.json')));

program
    .version(pkg.version)
    ;

program
    .command('parse [file...]')
    .description('extract data from CSS files')
    .option('-d, --directory <path>', 'change the working directory')
    .option('-o, --output <file>',    'save results to the given file')
    .option('--unique-selectors',     'consider only unique selectors')
    .on('--help', function() {
        console.log('  Examples:');
        console.log('');
        console.log('    $ node-specificity parse css/main.css css/print.css');
        console.log('    $ node-specificity parse css/**/*.css');
        console.log('    $ node-specificity parse --output=css.json --directory=css **/*.css');
        console.log('');
    })
    .action(function (options) {
        var cwd = this.directory ? path.resolve(this.directory) : process.cwd(),
            files = [];
        options.forEach(function (opt) {
            glob.sync(path.join(cwd, opt)).forEach(function (file) {
                var name = path.relative(cwd, file);
                if (files.indexOf(name) === -1) {
                    files.push(name);
                }
            });
        });
        if (files.length) {
            var result = specificity.parse(files, {
                cwd: cwd,
                uniqueSelectors: !!this.uniqueSelectors
            });
            if (this.output) {
                fs.writeFileSync(this.output, JSON.stringify(result));
            } else {
                console.log(JSON.stringify(result));
            }
        } else {
            this.help();
        }
    })
    ;

program
    .command('explore <file...>')
    .description('represent the outcomes of a parse')
    .option('-r, --report <name>', 'specify the report name [inspect]: inspect, json', 'inspect')
    .action(function (files, options) {
        if (files.length === 0) {
            this.help();
        } else {
            var data = files.map(function (file) {
                var json;
                try {
                    if (file === '-') {
                        json = readStdInSync();
                    } else {
                        json = fs.readFileSync(file, 'utf8');
                    }
                    json = JSON.parse(json)
                } catch (e) {
                    console.error(e.toString());
                    process.exit(2);
                }
                return {
                    file: file,
                    json: json
                };
            });
            try {
                var report = require(path.join('..', 'src', 'reports', this.report));
            } catch (e) {
                console.error('ERROR: unsupported report.' + e.toString());
                process.exit(3);
            }
            report(data);
        }
    })
    ;

program
    .on('*', function() {
        program.help();
    });

// EPIPE error happens constantly when program is writing to stdout through a pipe that has been closed.
// More information: https://github.com/joyent/node/issues/3211
process.stdout.on('error', function (err) {
    if (err.code === 'EPIPE') {
        process.exit();
    }
})

program.parse(process.argv);

if (!program.args.length) program.help();

function readStdInSync() {
    var result = '',
        bufSize = 512,
        buf = new Buffer(bufSize),
        bytes;
    process.stdin.resume();
    for (;;) {
        try {
            bytes = fs.readSync(process.stdin.fd, buf, 0, bufSize);
        } catch (e) {
            if (e.code === 'EAGAIN') {
                console.error('ERROR: interactive stdin input not supported.');
                process.exit(1);
            } else if (e.code === 'EOF') {
                break;
            }
            throw e;
        }
        if (bytes === 0) {
            break;
        }
        result += buf.toString('utf8', 0, bytes);
    }
    process.stdin.pause();
    return result;
}
